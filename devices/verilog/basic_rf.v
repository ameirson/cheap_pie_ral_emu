// This file was autogenerated by PeakRDL-verilog
module basic_rf #(
    parameter                                ADDR_OFFSET = 0,  //! Module's offset in the main address map
    parameter                                ADDR_WIDTH  = 32,   //! Width of SW address bus
    parameter                                DATA_WIDTH  = 32    //! Width of SW data bus
)(
    // Clocks and resets
    input logic                              clk,     //! Default clock
    input logic                              resetn,  //! Default reset

    // Register BASICREG
    output logic                             basicreg_basicfield_swmod,          //! Indicates SW has modified this field
    input  logic                             basicreg_basicfield_we,             //! Control HW write (active high)
    input  logic                     [31: 0] basicreg_basicfield_wdata,          //! HW write data

    // Register Bus
    input  logic                             valid,    //! Active high valid
    input  logic                             read,     //! Indicates request is a read
    input  logic            [ADDR_WIDTH-1:0] addr,     //! Address (byte aligned, absolute address)
    /* verilator lint_off UNUSED */
    input  logic            [DATA_WIDTH-1:0] wdata,    //! Write data
    input  logic          [DATA_WIDTH/8-1:0] wmask,    //! Write mask
    /* verilator lint_on UNUSED */
    output logic            [DATA_WIDTH-1:0] rdata     //! Read data
);

/* verilator lint_off UNUSED */
    // local output signals for fields (unless block outputs)
    // these can be used as references in other fields
    logic                           [31: 0] basicreg_basicfield_q;
    logic                           [31: 0] basicreg_basicfield_next;
    logic                             basicreg_basicfield_anded;
    logic                             basicreg_basicfield_ored;
    logic                             basicreg_basicfield_xored;
/* verilator lint_on UNUSED */

    // ============================================================
    // SW Access logic
    // ============================================================
    logic sw_wr;
    logic sw_rd;
    /* verilator lint_off UNUSED */
    logic [DATA_WIDTH-1:0] sw_mask;
    logic [DATA_WIDTH-1:0] sw_wdata;
    logic [DATA_WIDTH-1:0] sw_rdata;
    logic [DATA_WIDTH-1:0] sw_masked_data;
    /* verilator lint_on UNUSED */

    // convert bus interface to internal sw_* signals
    assign sw_wr    = valid && !read;
    assign sw_rd    = valid &&  read;
    assign sw_wdata = wdata;
    assign rdata    = sw_rdata;

    // convert byte mask to bit mask
    always_comb begin
        int byte_idx;
        for (byte_idx = 0; byte_idx < DATA_WIDTH/8; byte_idx+=1) begin
            sw_mask[8*(byte_idx+1)-1 -: 8] = {8{wmask[byte_idx]}};
        end
    end

    // helpful masked version of data
    assign sw_masked_data = sw_wdata & sw_mask;
    logic                     [DATA_WIDTH-1:0] basicreg_rdata;

    assign sw_rdata = // or of each register return (masked)
                   basicreg_rdata;
            
        
    // ============================================================
    // Register: BASICREG
    //    [31: 0]           basicfield: hw=w     sw=rw    reset=0x0
    // ============================================================
    logic                  basicreg_decode;
    logic                  basicreg_sw_wr;
    logic                  basicreg_sw_rd;
    logic [DATA_WIDTH-1:0] basicreg_q;

    assign basicreg_decode = (addr == (ADDR_OFFSET+'h0+'h0));
    assign basicreg_sw_wr = sw_wr && basicreg_decode;
    assign basicreg_sw_rd = sw_rd && basicreg_decode;

    always_comb begin
        basicreg_q = '0;
        basicreg_q[31: 0] = basicreg_basicfield_q;
    end

    // masked version of return data
    assign basicreg_rdata = basicreg_sw_rd ? basicreg_q : 'b0;

    // ------------------------------------------------------------
    // Field: basicfield
    // ------------------------------------------------------------
    assign basicreg_basicfield_anded = & basicreg_basicfield_q;
    assign basicreg_basicfield_ored  = | basicreg_basicfield_q;
    assign basicreg_basicfield_xored = ^ basicreg_basicfield_q;

    // next hardware value
    assign basicreg_basicfield_next = basicreg_basicfield_wdata;

    //! main storage
    always @ (posedge clk, negedge resetn)
    if (~resetn) begin
        basicreg_basicfield_q <= 0;
        basicreg_basicfield_swmod <= 1'b0;
    end else begin
        basicreg_basicfield_swmod <= 1'b0;
        // Hardware Write
        if (basicreg_basicfield_we) begin
            basicreg_basicfield_q <= basicreg_basicfield_next;
        end
        // Software write
        else if (basicreg_sw_wr) begin
            basicreg_basicfield_swmod <= 1'b1;
            basicreg_basicfield_q <=  sw_masked_data[31: 0] | (basicreg_basicfield_q & ~sw_mask[31: 0]);
        end
    end

endmodule: basic_rf
