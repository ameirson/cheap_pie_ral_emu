// This file was autogenerated by PeakRDL-verilog
module counter_rf #(
    parameter                                ADDR_OFFSET = 0,  //! Module's offset in the main address map
    parameter                                ADDR_WIDTH  = 32,   //! Width of SW address bus
    parameter                                DATA_WIDTH  = 32    //! Width of SW data bus
)(
    // Clocks and resets
    input logic                              clk,     //! Default clock
    input logic                              resetn,  //! Default reset

    // Register BASICREG
    input  logic                             basicreg_basicfield_we,             //! Control HW write (active high)
    input  logic                     [31: 0] basicreg_basicfield_wdata,          //! HW write data
    output logic                     [31: 0] basicreg_basicfield_q,              //! Current field value

    // Register EX1_CH9_8_1
    output logic                     [ 3: 0] ex1_ch9_8_1_count1_q,              //! Current field value
    input  logic                             ex1_ch9_8_1_count1_incr,           //! Increment the counter
    output logic                     [ 2: 0] ex1_ch9_8_1_count2_q,              //! Current field value
    input  logic                             ex1_ch9_8_1_count2_decr, //! Decrement the counter
    input  logic                     [2-1:0] ex1_ch9_8_1_count2_decrvalue, //! Decremenet amount
    output logic                     [ 4: 0] ex1_ch9_8_1_count3_q,              //! Current field value
    input  logic                             ex1_ch9_8_1_count3_incr,           //! Increment the counter
    input  logic                             ex1_ch9_8_1_count3_decr, //! Decrement the counter
    output logic                     [ 7: 0] ex1_ch9_8_1_count4_incr_q,              //! Current field value
    output logic                     [ 7: 0] ex1_ch9_8_1_count4_q,              //! Current field value
    input  logic                             ex1_ch9_8_1_count4_incr,           //! Increment the counter

    // Register COUNT1_LOW
    input  logic                             count1_low_count_we,             //! Control HW write (active high)
    input  logic                     [15: 0] count1_low_count_wdata,          //! HW write data
    output logic                     [15: 0] count1_low_count_q,              //! Current field value
    input  logic                             count1_low_count_incr,           //! Increment the counter

    // Register COUNT1_HIGH
    input  logic                             count1_high_count_we,             //! Control HW write (active high)
    input  logic                     [15: 0] count1_high_count_wdata,          //! HW write data
    output logic                     [15: 0] count1_high_count_q,              //! Current field value

    // Register EX1_CH9_8_2
    input  logic                             ex1_ch9_8_2_count1_we,             //! Control HW write (active high)
    input  logic                     [ 3: 0] ex1_ch9_8_2_count1_wdata,          //! HW write data
    output logic                     [ 3: 0] ex1_ch9_8_2_count1_q,              //! Current field value
    input  logic                             ex1_ch9_8_2_count1_incr,           //! Increment the counter
    output logic                             ex1_ch9_8_2_count1_incrsaturate,   //! Indicates the counter has saturated at upper limit
    input  logic                             ex1_ch9_8_2_count2_we,             //! Control HW write (active high)
    input  logic                     [ 2: 0] ex1_ch9_8_2_count2_wdata,          //! HW write data
    output logic                     [ 2: 0] ex1_ch9_8_2_count2_q,              //! Current field value
    input  logic                             ex1_ch9_8_2_count2_incr,           //! Increment the counter
    input  logic                             ex1_ch9_8_2_count3_we,             //! Control HW write (active high)
    input  logic                     [ 4: 0] ex1_ch9_8_2_count3_wdata,          //! HW write data
    output logic                     [ 4: 0] ex1_ch9_8_2_count3_q,              //! Current field value
    input  logic                             ex1_ch9_8_2_count3_incr,           //! Increment the counter
    output logic                             ex1_ch9_8_2_count3_incrsaturate,   //! Indicates the counter has saturated at upper limit
    input  logic                             ex1_ch9_8_2_count4_sat_we,             //! Control HW write (active high)
    input  logic                     [ 3: 0] ex1_ch9_8_2_count4_sat_wdata,          //! HW write data
    output logic                     [ 3: 0] ex1_ch9_8_2_count4_sat_q,              //! Current field value
    input  logic                             ex1_ch9_8_2_count4_thresh_we,             //! Control HW write (active high)
    input  logic                     [ 3: 0] ex1_ch9_8_2_count4_thresh_wdata,          //! HW write data
    output logic                     [ 3: 0] ex1_ch9_8_2_count4_thresh_q,              //! Current field value
    input  logic                             ex1_ch9_8_2_count4_we,             //! Control HW write (active high)
    input  logic                     [ 3: 0] ex1_ch9_8_2_count4_wdata,          //! HW write data
    output logic                     [ 3: 0] ex1_ch9_8_2_count4_q,              //! Current field value
    input  logic                             ex1_ch9_8_2_count4_incr,           //! Increment the counter
    output logic                             ex1_ch9_8_2_count4_incrthreshold,  //! Indicates the counter has reached the upper threshold
    output logic                             ex1_ch9_8_2_count4_incrsaturate,   //! Indicates the counter has saturated at upper limit

    // Register Bus
    input  logic                             valid,    //! Active high valid
    input  logic                             read,     //! Indicates request is a read
    input  logic            [ADDR_WIDTH-1:0] addr,     //! Address (byte aligned, absolute address)
    /* verilator lint_off UNUSED */
    input  logic            [DATA_WIDTH-1:0] wdata,    //! Write data
    input  logic          [DATA_WIDTH/8-1:0] wmask,    //! Write mask
    /* verilator lint_on UNUSED */
    output logic            [DATA_WIDTH-1:0] rdata     //! Read data
);

/* verilator lint_off UNUSED */
    // local output signals for fields (unless block outputs)
    // these can be used as references in other fields
    logic                           [31: 0] basicreg_basicfield_next;
    logic                             basicreg_basicfield_anded;
    logic                             basicreg_basicfield_ored;
    logic                             basicreg_basicfield_xored;
    logic                           [ 3: 0] ex1_ch9_8_1_count1_next;
    logic                             ex1_ch9_8_1_count1_anded;
    logic                             ex1_ch9_8_1_count1_ored;
    logic                             ex1_ch9_8_1_count1_xored;
    logic                             ex1_ch9_8_1_count1_overflow;
    logic                             ex1_ch9_8_1_count1_incrthreshold;
    logic                             ex1_ch9_8_1_count1_incrsaturate;
    logic                           [ 2: 0] ex1_ch9_8_1_count2_next;
    logic                             ex1_ch9_8_1_count2_anded;
    logic                             ex1_ch9_8_1_count2_ored;
    logic                             ex1_ch9_8_1_count2_xored;
    logic                             ex1_ch9_8_1_count2_underflow;
    logic                             ex1_ch9_8_1_count2_decrthreshold;
    logic                             ex1_ch9_8_1_count2_decrsaturate;
    logic                           [ 4: 0] ex1_ch9_8_1_count3_next;
    logic                             ex1_ch9_8_1_count3_anded;
    logic                             ex1_ch9_8_1_count3_ored;
    logic                             ex1_ch9_8_1_count3_xored;
    logic                             ex1_ch9_8_1_count3_overflow;
    logic                             ex1_ch9_8_1_count3_incrthreshold;
    logic                             ex1_ch9_8_1_count3_incrsaturate;
    logic                             ex1_ch9_8_1_count3_underflow;
    logic                             ex1_ch9_8_1_count3_decrthreshold;
    logic                             ex1_ch9_8_1_count3_decrsaturate;
    logic                           [ 7: 0] ex1_ch9_8_1_count4_incr_next;
    logic                             ex1_ch9_8_1_count4_incr_anded;
    logic                             ex1_ch9_8_1_count4_incr_ored;
    logic                             ex1_ch9_8_1_count4_incr_xored;
    logic                           [ 7: 0] ex1_ch9_8_1_count4_next;
    logic                             ex1_ch9_8_1_count4_anded;
    logic                             ex1_ch9_8_1_count4_ored;
    logic                             ex1_ch9_8_1_count4_xored;
    logic                             ex1_ch9_8_1_count4_overflow;
    logic                             ex1_ch9_8_1_count4_incrthreshold;
    logic                             ex1_ch9_8_1_count4_incrsaturate;
    logic                           [15: 0] count1_low_count_next;
    logic                             count1_low_count_anded;
    logic                             count1_low_count_ored;
    logic                             count1_low_count_xored;
    logic                             count1_low_count_overflow;
    logic                             count1_low_count_incrthreshold;
    logic                             count1_low_count_incrsaturate;
    logic                           [15: 0] count1_high_count_next;
    logic                             count1_high_count_anded;
    logic                             count1_high_count_ored;
    logic                             count1_high_count_xored;
    logic                             count1_high_count_overflow;
    logic                             count1_high_count_incrthreshold;
    logic                             count1_high_count_incrsaturate;
    logic                           [ 3: 0] ex1_ch9_8_2_count1_next;
    logic                             ex1_ch9_8_2_count1_anded;
    logic                             ex1_ch9_8_2_count1_ored;
    logic                             ex1_ch9_8_2_count1_xored;
    logic                             ex1_ch9_8_2_count1_overflow;
    logic                             ex1_ch9_8_2_count1_incrthreshold;
    logic                           [ 2: 0] ex1_ch9_8_2_count2_next;
    logic                             ex1_ch9_8_2_count2_anded;
    logic                             ex1_ch9_8_2_count2_ored;
    logic                             ex1_ch9_8_2_count2_xored;
    logic                             ex1_ch9_8_2_count2_overflow;
    logic                             ex1_ch9_8_2_count2_incrthreshold;
    logic                             ex1_ch9_8_2_count2_incrsaturate;
    logic                           [ 4: 0] ex1_ch9_8_2_count3_next;
    logic                             ex1_ch9_8_2_count3_anded;
    logic                             ex1_ch9_8_2_count3_ored;
    logic                             ex1_ch9_8_2_count3_xored;
    logic                             ex1_ch9_8_2_count3_overflow;
    logic                             ex1_ch9_8_2_count3_incrthreshold;
    logic                           [ 3: 0] ex1_ch9_8_2_count4_sat_next;
    logic                             ex1_ch9_8_2_count4_sat_anded;
    logic                             ex1_ch9_8_2_count4_sat_ored;
    logic                             ex1_ch9_8_2_count4_sat_xored;
    logic                           [ 3: 0] ex1_ch9_8_2_count4_thresh_next;
    logic                             ex1_ch9_8_2_count4_thresh_anded;
    logic                             ex1_ch9_8_2_count4_thresh_ored;
    logic                             ex1_ch9_8_2_count4_thresh_xored;
    logic                           [ 3: 0] ex1_ch9_8_2_count4_next;
    logic                             ex1_ch9_8_2_count4_anded;
    logic                             ex1_ch9_8_2_count4_ored;
    logic                             ex1_ch9_8_2_count4_xored;
    logic                             ex1_ch9_8_2_count4_overflow;
/* verilator lint_on UNUSED */

    // ============================================================
    // SW Access logic
    // ============================================================
    logic sw_wr;
    logic sw_rd;
    /* verilator lint_off UNUSED */
    logic [DATA_WIDTH-1:0] sw_mask;
    logic [DATA_WIDTH-1:0] sw_wdata;
    logic [DATA_WIDTH-1:0] sw_rdata;
    logic [DATA_WIDTH-1:0] sw_masked_data;
    /* verilator lint_on UNUSED */

    // convert bus interface to internal sw_* signals
    assign sw_wr    = valid && !read;
    assign sw_rd    = valid &&  read;
    assign sw_wdata = wdata;
    assign rdata    = sw_rdata;

    // convert byte mask to bit mask
    always_comb begin
        int byte_idx;
        for (byte_idx = 0; byte_idx < DATA_WIDTH/8; byte_idx+=1) begin
            sw_mask[8*(byte_idx+1)-1 -: 8] = {8{wmask[byte_idx]}};
        end
    end

    // helpful masked version of data
    assign sw_masked_data = sw_wdata & sw_mask;
    logic                     [DATA_WIDTH-1:0] basicreg_rdata;
    logic                     [DATA_WIDTH-1:0] ex1_ch9_8_1_rdata;
    logic                     [DATA_WIDTH-1:0] count1_low_rdata;
    logic                     [DATA_WIDTH-1:0] count1_high_rdata;
    logic                     [DATA_WIDTH-1:0] ex1_ch9_8_2_rdata;

    assign sw_rdata = // or of each register return (masked)
                   basicreg_rdata | 
                   ex1_ch9_8_1_rdata | 
                   count1_low_rdata | 
                   count1_high_rdata | 
                   ex1_ch9_8_2_rdata;
            
        
    // ============================================================
    // Register: BASICREG
    //    [31: 0]           basicfield: hw=rw    sw=rw    reset=0x0
    // ============================================================
    logic                  basicreg_decode;
    logic                  basicreg_sw_wr;
    logic                  basicreg_sw_rd;
    logic [DATA_WIDTH-1:0] basicreg_q;

    assign basicreg_decode = (addr == (ADDR_OFFSET+'h0+'h0));
    assign basicreg_sw_wr = sw_wr && basicreg_decode;
    assign basicreg_sw_rd = sw_rd && basicreg_decode;

    always_comb begin
        basicreg_q = '0;
        basicreg_q[31: 0] = basicreg_basicfield_q;
    end

    // masked version of return data
    assign basicreg_rdata = basicreg_sw_rd ? basicreg_q : 'b0;

    // ------------------------------------------------------------
    // Field: basicfield
    // ------------------------------------------------------------
    assign basicreg_basicfield_anded = & basicreg_basicfield_q;
    assign basicreg_basicfield_ored  = | basicreg_basicfield_q;
    assign basicreg_basicfield_xored = ^ basicreg_basicfield_q;

    // next hardware value
    assign basicreg_basicfield_next = basicreg_basicfield_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        basicreg_basicfield_q <= 0;
    end else begin
        // Hardware Write
        if (basicreg_basicfield_we) begin
            basicreg_basicfield_q <= basicreg_basicfield_next;
        end
        // Software write
        if (basicreg_sw_wr) begin
            basicreg_basicfield_q <=  sw_masked_data[31: 0] | (basicreg_basicfield_q & ~sw_mask[31: 0]);
        end
    end
            
        
    // ============================================================
    // Register: EX1_CH9_8_1
    //    [ 3: 0]               count1: hw=r     sw=rw    reset=0x0
    //    [ 6: 4]               count2: hw=r     sw=rw    reset=0x0
    //    [11: 7]               count3: hw=r     sw=rw    reset=0x0
    //    [19:12]          count4_incr: hw=r     sw=rw    reset=0xf
    //    [27:20]               count4: hw=r     sw=rw    reset=0x0
    // ============================================================
    logic                  ex1_ch9_8_1_decode;
    logic                  ex1_ch9_8_1_sw_wr;
    logic                  ex1_ch9_8_1_sw_rd;
    logic [DATA_WIDTH-1:0] ex1_ch9_8_1_q;

    assign ex1_ch9_8_1_decode = (addr == (ADDR_OFFSET+'h0+'h4));
    assign ex1_ch9_8_1_sw_wr = sw_wr && ex1_ch9_8_1_decode;
    assign ex1_ch9_8_1_sw_rd = sw_rd && ex1_ch9_8_1_decode;

    always_comb begin
        ex1_ch9_8_1_q = '0;
        ex1_ch9_8_1_q[ 3: 0] = ex1_ch9_8_1_count1_q;
        ex1_ch9_8_1_q[ 6: 4] = ex1_ch9_8_1_count2_q;
        ex1_ch9_8_1_q[11: 7] = ex1_ch9_8_1_count3_q;
        ex1_ch9_8_1_q[19:12] = ex1_ch9_8_1_count4_incr_q;
        ex1_ch9_8_1_q[27:20] = ex1_ch9_8_1_count4_q;
    end

    // masked version of return data
    assign ex1_ch9_8_1_rdata = ex1_ch9_8_1_sw_rd ? ex1_ch9_8_1_q : 'b0;

    // ------------------------------------------------------------
    // Field: count1 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_1_count1_anded = & ex1_ch9_8_1_count1_q;
    assign ex1_ch9_8_1_count1_ored  = | ex1_ch9_8_1_count1_q;
    assign ex1_ch9_8_1_count1_xored = ^ ex1_ch9_8_1_count1_q;

    // next hardware value

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_1_count1_q <= 0;
    end else begin
        // Counter increment
        ex1_ch9_8_1_count1_overflow <= 1'b0;
        if (ex1_ch9_8_1_count1_incr) begin
            logic [4:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_1_count1_q + 3;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_1_count1_overflow,
                ex1_ch9_8_1_count1_q } <= next;
        end
        // Software write
        if (ex1_ch9_8_1_sw_wr) begin
            ex1_ch9_8_1_count1_q <=  sw_masked_data[ 3: 0] | (ex1_ch9_8_1_count1_q & ~sw_mask[ 3: 0]);
        end
    end

    // ------------------------------------------------------------
    // Field: count2 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_1_count2_anded = & ex1_ch9_8_1_count2_q;
    assign ex1_ch9_8_1_count2_ored  = | ex1_ch9_8_1_count2_q;
    assign ex1_ch9_8_1_count2_xored = ^ ex1_ch9_8_1_count2_q;

    // next hardware value

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_1_count2_q <= 0;
    end else begin
        // Counter decrement
        ex1_ch9_8_1_count2_underflow <= 1'b0;
        if (ex1_ch9_8_1_count2_decr) begin
            logic [7:4] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_1_count2_q - ex1_ch9_8_1_count2_decrvalue;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_1_count2_underflow,
                ex1_ch9_8_1_count2_q } <= next;
        end
        // Software write
        if (ex1_ch9_8_1_sw_wr) begin
            ex1_ch9_8_1_count2_q <=  sw_masked_data[ 6: 4] | (ex1_ch9_8_1_count2_q & ~sw_mask[ 6: 4]);
        end
    end

    // ------------------------------------------------------------
    // Field: count3 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_1_count3_anded = & ex1_ch9_8_1_count3_q;
    assign ex1_ch9_8_1_count3_ored  = | ex1_ch9_8_1_count3_q;
    assign ex1_ch9_8_1_count3_xored = ^ ex1_ch9_8_1_count3_q;

    // next hardware value

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_1_count3_q <= 0;
    end else begin
        // Counter increment
        ex1_ch9_8_1_count3_overflow <= 1'b0;
        if (ex1_ch9_8_1_count3_incr) begin
            logic [5:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_1_count3_q + 2;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_1_count3_overflow,
                ex1_ch9_8_1_count3_q } <= next;
        end
        // Counter decrement
        ex1_ch9_8_1_count3_underflow <= 1'b0;
        if (ex1_ch9_8_1_count3_decr) begin
            logic [12:7] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_1_count3_q - 4;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_1_count3_underflow,
                ex1_ch9_8_1_count3_q } <= next;
        end
        // Software write
        if (ex1_ch9_8_1_sw_wr) begin
            ex1_ch9_8_1_count3_q <=  sw_masked_data[11: 7] | (ex1_ch9_8_1_count3_q & ~sw_mask[11: 7]);
        end
    end

    // ------------------------------------------------------------
    // Field: count4_incr
    // ------------------------------------------------------------
    assign ex1_ch9_8_1_count4_incr_anded = & ex1_ch9_8_1_count4_incr_q;
    assign ex1_ch9_8_1_count4_incr_ored  = | ex1_ch9_8_1_count4_incr_q;
    assign ex1_ch9_8_1_count4_incr_xored = ^ ex1_ch9_8_1_count4_incr_q;

    // next hardware value

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_1_count4_incr_q <= 15;
    end else begin
        // Software write
        if (ex1_ch9_8_1_sw_wr) begin
            ex1_ch9_8_1_count4_incr_q <=  sw_masked_data[19:12] | (ex1_ch9_8_1_count4_incr_q & ~sw_mask[19:12]);
        end
    end

    // ------------------------------------------------------------
    // Field: count4 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_1_count4_anded = & ex1_ch9_8_1_count4_q;
    assign ex1_ch9_8_1_count4_ored  = | ex1_ch9_8_1_count4_q;
    assign ex1_ch9_8_1_count4_xored = ^ ex1_ch9_8_1_count4_q;

    // next hardware value

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_1_count4_q <= 0;
    end else begin
        // Counter increment
        ex1_ch9_8_1_count4_overflow <= 1'b0;
        if (ex1_ch9_8_1_count4_incr) begin
            logic [8:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_1_count4_q + ex1_ch9_8_1_count4_incr_q;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_1_count4_overflow,
                ex1_ch9_8_1_count4_q } <= next;
        end
        // Software write
        if (ex1_ch9_8_1_sw_wr) begin
            ex1_ch9_8_1_count4_q <=  sw_masked_data[27:20] | (ex1_ch9_8_1_count4_q & ~sw_mask[27:20]);
        end
    end
            
        
    // ============================================================
    // Register: COUNT1_LOW
    //    [15: 0]                count: hw=rw    sw=rw    reset=0x0
    // ============================================================
    logic                  count1_low_decode;
    logic                  count1_low_sw_wr;
    logic                  count1_low_sw_rd;
    logic [DATA_WIDTH-1:0] count1_low_q;

    assign count1_low_decode = (addr == (ADDR_OFFSET+'h0+'h8));
    assign count1_low_sw_wr = sw_wr && count1_low_decode;
    assign count1_low_sw_rd = sw_rd && count1_low_decode;

    always_comb begin
        count1_low_q = '0;
        count1_low_q[15: 0] = count1_low_count_q;
    end

    // masked version of return data
    assign count1_low_rdata = count1_low_sw_rd ? count1_low_q : 'b0;

    // ------------------------------------------------------------
    // Field: count (counter)
    // ------------------------------------------------------------
    assign count1_low_count_anded = & count1_low_count_q;
    assign count1_low_count_ored  = | count1_low_count_q;
    assign count1_low_count_xored = ^ count1_low_count_q;

    // next hardware value
    assign count1_low_count_next = count1_low_count_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        count1_low_count_q <= 0;
    end else begin
        // Hardware Write
        if (count1_low_count_we) begin
            count1_low_count_q <= count1_low_count_next;
        end
        // Counter increment
        count1_low_count_overflow <= 1'b0;
        if (count1_low_count_incr) begin
            logic [16:0] next;
            /* verilator lint_off WIDTH */
            next = count1_low_count_q + 1;
            /* verilator lint_on WIDTH */

            { count1_low_count_overflow,
                count1_low_count_q } <= next;
        end
        // Software write
        if (count1_low_sw_wr) begin
            count1_low_count_q <=  sw_masked_data[15: 0] | (count1_low_count_q & ~sw_mask[15: 0]);
        end
    end
            
        
    // ============================================================
    // Register: COUNT1_HIGH
    //    [15: 0]                count: hw=rw    sw=rw    reset=0x0
    // ============================================================
    logic                  count1_high_decode;
    logic                  count1_high_sw_wr;
    logic                  count1_high_sw_rd;
    logic [DATA_WIDTH-1:0] count1_high_q;

    assign count1_high_decode = (addr == (ADDR_OFFSET+'h0+'ha));
    assign count1_high_sw_wr = sw_wr && count1_high_decode;
    assign count1_high_sw_rd = sw_rd && count1_high_decode;

    always_comb begin
        count1_high_q = '0;
        count1_high_q[15: 0] = count1_high_count_q;
    end

    // masked version of return data
    assign count1_high_rdata = count1_high_sw_rd ? count1_high_q : 'b0;

    // ------------------------------------------------------------
    // Field: count (counter)
    // ------------------------------------------------------------
    assign count1_high_count_anded = & count1_high_count_q;
    assign count1_high_count_ored  = | count1_high_count_q;
    assign count1_high_count_xored = ^ count1_high_count_q;

    // next hardware value
    assign count1_high_count_next = count1_high_count_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        count1_high_count_q <= 0;
    end else begin
        // Hardware Write
        if (count1_high_count_we) begin
            count1_high_count_q <= count1_high_count_next;
        end
        // Counter increment
        count1_high_count_overflow <= 1'b0;
        if (count1_low_count_overflow) begin
            logic [16:0] next;
            /* verilator lint_off WIDTH */
            next = count1_high_count_q + 1;
            /* verilator lint_on WIDTH */

            { count1_high_count_overflow,
                count1_high_count_q } <= next;
        end
        // Software write
        if (count1_high_sw_wr) begin
            count1_high_count_q <=  sw_masked_data[15: 0] | (count1_high_count_q & ~sw_mask[15: 0]);
        end
    end
            
        
    // ============================================================
    // Register: EX1_CH9_8_2
    //    [ 3: 0]               count1: hw=rw    sw=rw    reset=0x0
    //    [ 6: 4]               count2: hw=rw    sw=rw    reset=0x0
    //    [11: 7]               count3: hw=rw    sw=rw    reset=0x0
    //    [15:12]           count4_sat: hw=rw    sw=rw    reset=0xa
    //    [19:16]        count4_thresh: hw=rw    sw=rw    reset=0x2
    //    [23:20]               count4: hw=rw    sw=rw    reset=0x0
    // ============================================================
    logic                  ex1_ch9_8_2_decode;
    logic                  ex1_ch9_8_2_sw_wr;
    logic                  ex1_ch9_8_2_sw_rd;
    logic [DATA_WIDTH-1:0] ex1_ch9_8_2_q;

    assign ex1_ch9_8_2_decode = (addr == (ADDR_OFFSET+'h0+'hc));
    assign ex1_ch9_8_2_sw_wr = sw_wr && ex1_ch9_8_2_decode;
    assign ex1_ch9_8_2_sw_rd = sw_rd && ex1_ch9_8_2_decode;

    always_comb begin
        ex1_ch9_8_2_q = '0;
        ex1_ch9_8_2_q[ 3: 0] = ex1_ch9_8_2_count1_q;
        ex1_ch9_8_2_q[ 6: 4] = ex1_ch9_8_2_count2_q;
        ex1_ch9_8_2_q[11: 7] = ex1_ch9_8_2_count3_q;
        ex1_ch9_8_2_q[15:12] = ex1_ch9_8_2_count4_sat_q;
        ex1_ch9_8_2_q[19:16] = ex1_ch9_8_2_count4_thresh_q;
        ex1_ch9_8_2_q[23:20] = ex1_ch9_8_2_count4_q;
    end

    // masked version of return data
    assign ex1_ch9_8_2_rdata = ex1_ch9_8_2_sw_rd ? ex1_ch9_8_2_q : 'b0;

    // ------------------------------------------------------------
    // Field: count1 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_2_count1_anded = & ex1_ch9_8_2_count1_q;
    assign ex1_ch9_8_2_count1_ored  = | ex1_ch9_8_2_count1_q;
    assign ex1_ch9_8_2_count1_xored = ^ ex1_ch9_8_2_count1_q;

    // next hardware value
    assign ex1_ch9_8_2_count1_next = ex1_ch9_8_2_count1_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_2_count1_q <= 0;
    end else begin
        // Hardware Write
        if (ex1_ch9_8_2_count1_we) begin
            ex1_ch9_8_2_count1_q <= ex1_ch9_8_2_count1_next;
        end
        // Counter increment
        ex1_ch9_8_2_count1_overflow <= 1'b0;
        if (ex1_ch9_8_2_count1_incr) begin
            logic [4:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_2_count1_q + 1;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_2_count1_overflow,
                ex1_ch9_8_2_count1_q } <= next;
            // saturate
            ex1_ch9_8_2_count1_overflow <= 1'b0;
            ex1_ch9_8_2_count1_incrsaturate <= 1'b0;
            if (next[4] ||
                (next[ 3: 0] >= 4'd14)) begin
                ex1_ch9_8_2_count1_q <= 4'd14;
                ex1_ch9_8_2_count1_incrsaturate <= 1'b1;
            end
        end
        // Software write
        if (ex1_ch9_8_2_sw_wr) begin
            ex1_ch9_8_2_count1_q <=  sw_masked_data[ 3: 0] | (ex1_ch9_8_2_count1_q & ~sw_mask[ 3: 0]);
        end
    end

    // ------------------------------------------------------------
    // Field: count2 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_2_count2_anded = & ex1_ch9_8_2_count2_q;
    assign ex1_ch9_8_2_count2_ored  = | ex1_ch9_8_2_count2_q;
    assign ex1_ch9_8_2_count2_xored = ^ ex1_ch9_8_2_count2_q;

    // next hardware value
    assign ex1_ch9_8_2_count2_next = ex1_ch9_8_2_count2_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_2_count2_q <= 0;
    end else begin
        // Hardware Write
        if (ex1_ch9_8_2_count2_we) begin
            ex1_ch9_8_2_count2_q <= ex1_ch9_8_2_count2_next;
        end
        // Counter increment
        ex1_ch9_8_2_count2_overflow <= 1'b0;
        if (ex1_ch9_8_2_count2_incr) begin
            logic [3:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_2_count2_q + 1;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_2_count2_overflow,
                ex1_ch9_8_2_count2_q } <= next;
        end
        // Software write
        if (ex1_ch9_8_2_sw_wr) begin
            ex1_ch9_8_2_count2_q <=  sw_masked_data[ 6: 4] | (ex1_ch9_8_2_count2_q & ~sw_mask[ 6: 4]);
        end
    end

    // ------------------------------------------------------------
    // Field: count3 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_2_count3_anded = & ex1_ch9_8_2_count3_q;
    assign ex1_ch9_8_2_count3_ored  = | ex1_ch9_8_2_count3_q;
    assign ex1_ch9_8_2_count3_xored = ^ ex1_ch9_8_2_count3_q;

    // next hardware value
    assign ex1_ch9_8_2_count3_next = ex1_ch9_8_2_count3_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_2_count3_q <= 0;
    end else begin
        // Hardware Write
        if (ex1_ch9_8_2_count3_we) begin
            ex1_ch9_8_2_count3_q <= ex1_ch9_8_2_count3_next;
        end
        // Counter increment
        ex1_ch9_8_2_count3_overflow <= 1'b0;
        if (ex1_ch9_8_2_count3_incr) begin
            logic [5:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_2_count3_q + 1;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_2_count3_overflow,
                ex1_ch9_8_2_count3_q } <= next;
            // saturate
            ex1_ch9_8_2_count3_overflow <= 1'b0;
            ex1_ch9_8_2_count3_incrsaturate <= 1'b0;
            if (next[5] ||
                (next[ 4: 0] >= 5'd31)) begin
                ex1_ch9_8_2_count3_q <= 5'd31;
                ex1_ch9_8_2_count3_incrsaturate <= 1'b1;
            end
        end
        // Software write
        if (ex1_ch9_8_2_sw_wr) begin
            ex1_ch9_8_2_count3_q <=  sw_masked_data[11: 7] | (ex1_ch9_8_2_count3_q & ~sw_mask[11: 7]);
        end
    end

    // ------------------------------------------------------------
    // Field: count4_sat
    // ------------------------------------------------------------
    assign ex1_ch9_8_2_count4_sat_anded = & ex1_ch9_8_2_count4_sat_q;
    assign ex1_ch9_8_2_count4_sat_ored  = | ex1_ch9_8_2_count4_sat_q;
    assign ex1_ch9_8_2_count4_sat_xored = ^ ex1_ch9_8_2_count4_sat_q;

    // next hardware value
    assign ex1_ch9_8_2_count4_sat_next = ex1_ch9_8_2_count4_sat_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_2_count4_sat_q <= 10;
    end else begin
        // Hardware Write
        if (ex1_ch9_8_2_count4_sat_we) begin
            ex1_ch9_8_2_count4_sat_q <= ex1_ch9_8_2_count4_sat_next;
        end
        // Software write
        if (ex1_ch9_8_2_sw_wr) begin
            ex1_ch9_8_2_count4_sat_q <=  sw_masked_data[15:12] | (ex1_ch9_8_2_count4_sat_q & ~sw_mask[15:12]);
        end
    end

    // ------------------------------------------------------------
    // Field: count4_thresh
    // ------------------------------------------------------------
    assign ex1_ch9_8_2_count4_thresh_anded = & ex1_ch9_8_2_count4_thresh_q;
    assign ex1_ch9_8_2_count4_thresh_ored  = | ex1_ch9_8_2_count4_thresh_q;
    assign ex1_ch9_8_2_count4_thresh_xored = ^ ex1_ch9_8_2_count4_thresh_q;

    // next hardware value
    assign ex1_ch9_8_2_count4_thresh_next = ex1_ch9_8_2_count4_thresh_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_2_count4_thresh_q <= 2;
    end else begin
        // Hardware Write
        if (ex1_ch9_8_2_count4_thresh_we) begin
            ex1_ch9_8_2_count4_thresh_q <= ex1_ch9_8_2_count4_thresh_next;
        end
        // Software write
        if (ex1_ch9_8_2_sw_wr) begin
            ex1_ch9_8_2_count4_thresh_q <=  sw_masked_data[19:16] | (ex1_ch9_8_2_count4_thresh_q & ~sw_mask[19:16]);
        end
    end

    // ------------------------------------------------------------
    // Field: count4 (counter)
    // ------------------------------------------------------------
    assign ex1_ch9_8_2_count4_anded = & ex1_ch9_8_2_count4_q;
    assign ex1_ch9_8_2_count4_ored  = | ex1_ch9_8_2_count4_q;
    assign ex1_ch9_8_2_count4_xored = ^ ex1_ch9_8_2_count4_q;

    // next hardware value
    assign ex1_ch9_8_2_count4_next = ex1_ch9_8_2_count4_wdata;

    //! main storage
    always_ff @ (posedge clk, negedge resetn)
    if (~resetn) begin
        ex1_ch9_8_2_count4_q <= 0;
    end else begin
        // Hardware Write
        if (ex1_ch9_8_2_count4_we) begin
            ex1_ch9_8_2_count4_q <= ex1_ch9_8_2_count4_next;
        end
        // Counter increment
        ex1_ch9_8_2_count4_overflow <= 1'b0;
        if (ex1_ch9_8_2_count4_incr) begin
            logic [4:0] next;
            /* verilator lint_off WIDTH */
            next = ex1_ch9_8_2_count4_q + 1;
            /* verilator lint_on WIDTH */

            { ex1_ch9_8_2_count4_overflow,
                ex1_ch9_8_2_count4_q } <= next;
            // saturate
            ex1_ch9_8_2_count4_overflow <= 1'b0;
            ex1_ch9_8_2_count4_incrsaturate <= 1'b0;
            if (next[4] ||
                (next[ 3: 0] >= ex1_ch9_8_2_count4_sat_q)) begin
                ex1_ch9_8_2_count4_q <= ex1_ch9_8_2_count4_sat_q;
                ex1_ch9_8_2_count4_incrsaturate <= 1'b1;
            end

            // threshold
            ex1_ch9_8_2_count4_incrthreshold <= 1'b0;
            if (next[4] ||
                (next[ 3: 0] >= ex1_ch9_8_2_count4_thresh_q)) begin
                ex1_ch9_8_2_count4_incrthreshold <= 1'b1;
            end
        end
        // Software write
        if (ex1_ch9_8_2_sw_wr) begin
            ex1_ch9_8_2_count4_q <=  sw_masked_data[23:20] | (ex1_ch9_8_2_count4_q & ~sw_mask[23:20]);
        end
    end

endmodule: counter_rf
