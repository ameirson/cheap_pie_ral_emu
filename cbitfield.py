# Autogenerated with SMOP 
## this file is part of cheap_pie, a python tool for chip validation
## author: Marco Merlin
## email: marcomerli@gmail.com

from ast import literal_eval

class cp_bitfield:
    """A bitfield register class """
    #properties    
    # field width
    width = 1    
    # LSB
    lsb = 1
    
    # mask
    mask = 1
    
    # comments
    comments = ""
    
    # Address (Duplicate information)
    addr = 0
    
    # reg name
    regname = ""
    
    # field name
    fieldname = ""
    
    # host interface handler
    hif = None
    
    # read/write
    rw  = "rw"

    # reset value
    reset = 0

    def __init__(self, regfield="",regaddr=0, regname="",width="1", bit_offset="0",comments="",hif=None, rw = "rw", reset=0):

        if isinstance(width,str):
            width= literal_eval(width)
        # field width
        self.width = int( width )
        
        if isinstance(bit_offset,str):
            lsb=literal_eval(bit_offset)
        else:
            lsb = bit_offset
        self.lsb = int( lsb )
        
        if lsb is None:
            print('Bad definition for register field %s @ %s!' % regname,regfield)
            lsb=0
            
        if isinstance(regaddr,str):
            regaddr=literal_eval(regaddr)
        
        # mask
        # self.mask=bitshift(bin2dec(repmat('1',cat(1,width))),lsb)        
        bstr = "0b" + ("1" * self.width) + ("0" * self.lsb)        
        self.mask=literal_eval( bstr )        
        self.comments = comments
        self.addr = int( regaddr )
        self.regname = regname
        self.fieldname = regfield
        self.hif = hif
        self.rw = rw
        self.reset = reset
        
    def display(self,regval=None):
        """ displays value of a bitfield from a register value         
        input : regval value of the full register either in decimal or
        hexadecimal """
        
        if regval is None:
            if not (self.hif is None):
                regval=self.hif.hifread(self.addr)    
            else:
                regval=0
                
        # compute field value from register value
        if isinstance(regval, str):
            regval=literal_eval(regval)
        fieldval = (regval & self.mask ) >> (self.lsb)
        
        outstr= self.regname  + ' @ ' + self.fieldname  + ' [' + str(self.width) + '] = ' + hex(fieldval)
        print(outstr)
        return outstr
    
    def getbit(self,regval=None,*args,**kwargs):
        """ function display(self,regval)        
        # displays value of a bitfield from a register value        
        # input : regval value of the full register either in decimal or
                # hexadecimal"""
        
        if len(args) < 2:
            if not (self.hif is None):
                regval=self.hif.hifread(self.addr)
            else:
                regval=0        
        
        # compute field value from register value
        if isinstance(regval, str):
            regval=literal_eval(regval)
        fieldval = (regval & self.mask ) >> (self.lsb)

        # fieldval=self.value(regval)
        # if cp_bitfield.getbit.nargout == 0:
        outstr= self.regname + ' @ ' + self.fieldname + ' [' + str(self.width) + '] = ' + hex(fieldval)
        print(outstr)
        
        return fieldval
        
    def setbit(self,fieldval=0,*args,**kwargs):
        """ function display(self,regval)        
        # displays value of a bitfield from a register value
        
        # input : regval value of the full register either in decimal or
                # hexadecimal """
    
        ## read input register value ###################################################
        if not (self.hif is None):
            hexval=self.hif.hifread(self.addr)
            if isinstance(hexval, str):
                regval=literal_eval(hexval)
            else:
                regval = hexval
        else:
            regval=0
        
        ## handle char input as binary #################################################
        if isinstance(fieldval, str):
            fieldval = literal_eval(fieldval)

        ## compute new register value ##################################################
        
        shiftval= fieldval << self.lsb
        maskinv= self.mask ^ literal_eval('0xFFFFFFFF')
        regmasked = regval & maskinv
        outregval = regmasked + shiftval
    
        ## write back new register value ###############################################
        self.hif.hifwrite(self.addr,outregval)
        
        # if cp_bitfield.setbit.nargout == 0:
        outstr=self.regname + ' @ ' + self.fieldname + ' [' + str(self.width) + '] = ' + hex(fieldval)
        print(outstr)
        
        return fieldval
        
    #@function
    def help(self):
        """ function ret = help(self)        
        # displays register comments """    
        print(self.comments)

    #@function
    def value(self,regval=0):
        """ function ret = value(self,regval)        
        # Returns value of a bitfield from a register value        
        # input : regval value of the full register either in decimal or
                # hexadecimal """
        
        if isinstance(regval, str):
            regval=literal_eval(regval)
        
        # mask = dec2hex(self.mask)
                # lsb  = self.lsb
        
        # ret=bitshift(bitand(regval,self.mask),- (self.lsb))
        
        ret = (regval & self.mask ) >> (self.lsb)
        return ret
    
if __name__ == '__main__':
    pass
