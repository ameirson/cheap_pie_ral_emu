## this file is part of cheap_pie, a python tool for chip validation
## author: Marco Merlin
## email: marcomerli@gmail.com

# simplified manual initialization
# 
# import untangle
# hal = untangle.parse('QN908XC.xml')
# from cbitfield import cp_bitfield
# from cp_register import cp_register
# ADC_ANA_CTRL = cp_register("ADC_ANA_CTRL","0x4000702C", "ADC core and reference setting regsiter" , hif )
# ADC_BM = cp_bitfield("ADC_BM","0x4000702C","ADC_ANA_CTRL",3,0, "ADC bias current selection." ,hif)

# Autogenerated with SMOP 
# from smop.core import *
import untangle # for parsing xml
from ast import literal_eval
import string as str
from collections import namedtuple

from cbitfield import cp_bitfield
from cp_register import cp_register
    
#@function
def xmlreg2struct(fname="./devices/QN908XC.xml",hif=None,*args,**kwargs):
    
    ## get full file name #####################################################
    #if logical_not(exist(fname,'file')):
    #    fname,fpath=uigetfile('*.xml',nargout=2)
    #    fname=fullfile(fpath,fname)
    
    ## read input file ########################################################

    # csv=xml2struct(fname)
    csv = untangle.parse(fname)

    ## loop over lines ########################################################
    # outstruct=struct()
    outdict = dict()
    nperiph=len(csv.device.peripherals.peripheral)
    for periphidx in range(nperiph):
        if hasattr(csv.device.peripherals.peripheral[periphidx],'registers'):
            nreg=len(csv.device.peripherals.peripheral[periphidx].registers.register)
        else:
            nreg=0
        base_addr_str=csv.device.peripherals.peripheral[periphidx].baseAddress.cdata
        base_address=literal_eval(base_addr_str)

        for idx in range(nreg):
            
            if hasattr( csv.device.peripherals.peripheral[periphidx].registers.register[idx].name, 'cdata'):
                # close old register, before opening a new one
                if 'regname' in locals():
                    struct_register.dictfield2struct()
                    outdict[regname]=struct_register

                # new register
                periph_name=csv.device.peripherals.peripheral[periphidx].name.cdata

                rname=csv.device.peripherals.peripheral[periphidx].registers.register[idx].name.cdata
                regname = "%s_%s" % ( periph_name,rname )

                regname=name_subs(regname)
                addr_str=csv.device.peripherals.peripheral[periphidx].registers.register[idx].addressOffset.cdata
                regaddr=literal_eval(addr_str) + base_address
                comments=csv.device.peripherals.peripheral[periphidx].registers.register[idx].description
                struct_register=newreg(regname,regaddr,comments,hif)

                if hasattr(csv.device.peripherals.peripheral[periphidx].registers.register[idx],'fields'):
                    nfields=len(csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field)
                else:
                    nfields=0

                for field_idx in range(nfields):
                    if nfields > 1:
                        if hasattr(csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field[field_idx],'name') :
                            # print regname
                            regfield=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field[field_idx].name.cdata
                            # print regfield                                
                    else:
                        regfield=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field.name.cdata

                    if not(csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field[field_idx] is None):
                        # print regfield
                        regfield=name_subs(regfield)

                        if nfields > 1:
                            csvWidth=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field[field_idx].bitWidth.cdata
                            bitoffset=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field[field_idx].bitOffset.cdata
                            Comments=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field[field_idx].description

                        else:
                            csvWidth=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field.bitWidth.cdata
                            bitoffset=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field.bitOffset.cdata
                            Comments=csv.device.peripherals.peripheral[periphidx].registers.register[idx].fields.field.description

                        # Create new field class
                        class_regfield=newfield(regfield,regaddr,regname,csvWidth,bitoffset,Comments,hif)                        
                        struct_register.addfield(class_regfield)

        # create last register, if existing
        if 'regname' in locals():
            # outstruct=addreg2struct(outstruct,regname,struct_register)
            struct_register.dictfield2struct()
            outdict[regname]=struct_register
    
    # convert output dictionary into structure
    return namedtuple("HAL", outdict.keys())(*outdict.values())
    
#@function
def newreg(regname=None,regaddr=None,comments=None,hif=None):    
    class_register=cp_register(regname,regaddr,comments,hif)
    return class_register
    
#@function
def newfield(regfield=None,regaddr=None,regname=None,csvWidth=None,bit_offset=None,Comments=None,hif=None,*args,**kwargs):
    class_regfield=cp_bitfield(regfield,regaddr,regname,csvWidth,bit_offset,Comments,hif)   
    return class_regfield
    
    
#@function
def name_subs(regname=None,*args,**kwargs):

    # regname=strrep(regname,'"','')
    regname=str.replace(regname,'"','')
    regname=str.replace(regname,'[','')
    regname=str.replace(regname,']','')
    regname=str.replace(regname,'%','')
    if regname[1].isdigit():
        regname= 'M' + regname
    
    return regname
    
if __name__ == '__main__':
    xmlreg2struct()
    pass
    